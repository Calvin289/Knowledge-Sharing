目录

1 前言

2 面向对象

2.1 结构体

2.2 枚举缺陷

2.3 释放出this指针

2.4 宏是接口

2.4.1 唯一性

2.4.2 封装性

2.5 对象生命周期

2.6 参数方向

2.7 函数二元返回值

2.8 唯一编号

2.9 分布式模块

3 基础库

4 回调与触发


# 1 前言

BGN走过了漫长的18年岁月，而面向对象C编程我已运用了15年，因此C语言能不能面向对象编程这个问题，显然不是个问题。可以负责任地说，C语言不仅适合面向对象编程，而且强大到好玩。

面向对象编程是一种思想，不是一门语言。掌握方法精髓，不拘泥于形式，不生搬硬套，即便用shell，也能写出面向对象的感觉来。

在BGN代码量首次过10万行时，我已感受到一个人维护的压力。在反反复复的重构中，悟出面向对象的强大，直至目前在思想上和运用上成体系发展，支撑BGN的代码量估计超过200万行。

BGN与面向对象的关系，十分类似Linux与C的关系，因需而生，因需而变，交汇融合。

决定写这篇文章并不容易，我至少犹豫了四、五年，因为简单，所以更加艰难，因为本质，所以更易忽视。即便作出决定，依然没有十足的把握能写透彻，权当抛砖引玉，版本迭代中完善，不希望读者将其看作是一份编程规范。

谨以小文，作为BGN的18岁成人礼，纪念逝去的青春，纪念我的技术人生。


# 2 面向对象

本文无意区分对象、类、模块、实例这些概念，请读者根据上下文自行断定，以免学究，流于形式。姑且对它们下个统一的定义：一组数据以及对这组数据进行操作的集合。

## 2.1 结构体

为了便于组织数据，C语言发明了结构体，伴随而来的是层次关系，这是表达面向对象中继承性的重要手段之一。

结构体中的成员用不同的名称区分，在内存中顺序排列，与之对应的联合体，则是共用内存。

定义结构体时，建议根据机器字长，手动对齐，不必劳烦编译器。个人喜好按8字节对齐，同时适用于32位系统和64位系统。

## 2.2 枚举缺陷

枚举类型是鸡肋，给编译器做类型检测用，其功效完全可以用带类型约束的宏常量代替。

枚举的缺陷在于其字节数的不确定性，存在误判的风险，比如，

	typedef enum
	{
	    model_001   = 0,
	    model_002   = 1,
	    model_004   = 2
	}MODEL;

对该枚举类型取sizeof，通常结果是4字节。

修改一下，

	typedef enum
	{
	    model_001   = 0,
	    model_002   = 1,
	    model_004   = 0x000000002
	}MODEL;

或者

	typedef enum
	{
	    model_001   = 0,
	    model_002   = 1,
	    model_004   = (unsigned long long)0x000000002
	}MODEL;

我们期望sizeof结果是8字节，但依然是4字节。

鉴于此，历史上BGN一次性废弃了全部枚举类型，改为宏定义，比如可以改写成这样，

	#define MODEL_001     ((uint64_t) 0)
	#define MODEL_002     ((uint64_t) 1)
	#define MODEL_004     ((uint64_t) 2)

## 2.3 释放出this指针

C++和JAVA语言中，类成员函数参数表的第一个隐含参数是this指针，表示当前对象。

C语言自由奔放，不需要编译器准备该参数，可以纯手工添加，比如，

	void camd_process_pages(CAMD_MD *camd_md)

	void camd_process_page(CAMD_MD *camd_md, CAMD_PAGE *camd_page)

第一个参数camd_md表示当前模块CAMD_MD的一个实例化对象，相当于释放出this指针，函数名则表示对该对象的操作，或者该对象所执行的操作。

将对象放在首参位置是必须的、也是唯一的选择。

深入思考一下：对象是否必须由指针来表达？

答案是否定的，至少可以从两个方面来证明：其一，指针并非一定是内存地址，索引也可以看做是某种指针；其二，指针具有局部性，在单机单进程中有效，不能推而广之，在更大范围的分布式环境中有效。

## 2.4 宏是接口

宏，首先是字符串替换功能，为人熟知；其次是接口功能，用者寥寥，说不定我是原创者。

宏的接口功能在结构体成员的访问中，应用尤其频繁，举例，

	typedef struct
	{
	   int         fd;
	   int         rsvd;
	
	   UINT32     *max_req_num;
	   UINT32      cur_req_num;
	}CAIO_DISK;
	
	#define CAIO_DISK_FD(caio_disk)                         ((caio_disk)->fd)
	#define CAIO_DISK_MAX_REQ_NUM(caio_disk)                ((caio_disk)->max_req_num)
	#define CAIO_DISK_CUR_REQ_NUM(caio_disk)                ((caio_disk)->cur_req_num)

这是个有趣的话题：为什么要多此一举将结构体成员的访问封装到宏里？

主要是用到了宏的两个特性：唯一性、封装性。

### 2.4.1 唯一性

注意观察宏名规则：结构体名 + 成员名。在编码中适当规划一下，即可保证宏名的唯一性。这在后续的维护中、以及读码中会获益良多。

比如，要修改一个成员名称，那么找到所有该宏名出现的地方修改一次即可；增加或删除某个成员，手法类似；要查找某个成员在哪些地方使用的，查宏名即可，不必担心局部变量名和成员名重名的干扰。

### 2.4.2 封装性

仔细看宏接口的定义，它实际表达的是一个对象的操作：宏名是操作，参数是对象。典型的面向对象手法，与函数接口类似。换言之，对该结构体的所有最基本操作，封装进了宏接口中。

设想一下，如果上面的max_req_num类型不是指针类型，而是UINT32类型，已码完的代码些许变动即可适配，封装的优势明显。

事实上，宏接口在BGN中的应用遍地都是，令人发指。

## 2.5 对象生命周期

对象的生命周期管理通常严格划分为四个阶段：创建、初始化、清理和释放。举例，

	CAIO_DISK *caio_disk_new();                                 /*创建对象CAIO_DISK*/
	
	EC_BOOL caio_disk_init(CAIO_DISK *caio_disk);               /*初始化对象CAIO_DISK*/
	
	EC_BOOL caio_disk_clean(CAIO_DISK *caio_disk);              /*清理对象CAIO_DISK*/
	
	EC_BOOL caio_disk_free(CAIO_DISK *caio_disk);               /*释放对象CAIO_DISK*/

接口调用遵循原则：创建时立即初始化，释放前先清理。

对于静态对象生命周期管理，可以只保留初始化和清理两个阶段。

## 2.6 参数方向

函数的参数分为三个方向：入参，出参，出入参。用来指示参数值的变化与否。

入参是指只传入、不修改；出参是指只传出、不传入；出入参是指先传入，后传出。

通常，要尽量减少出入参的使用，能不用就不用，比如拆成一个入参、一个出参来代替，除非万不得已。

这是因为，入参可以在类型前面加const、出参不加const来标示，而出入参不方便与出参区分，辨识度差。

如果非要增加辨识度，可以手动加空宏定义，比如IN、OUT、IO之类的，在代码量大的情况下，啰嗦又臃肿，不建议。

## 2.7 函数二元返回值

函数看作是对象的某种操作，函数二元返回值是指，函数的返回值只表达该操作成功或者失败，其它要表达的返回值可以由出参带出。

强烈建议函数采用二元返回值模式，为什么呢？

函数要么没有返回值，要么有两个及以上的返回值。函数作为操作，其返回值必然为后续逻辑提供决策依据，也就是说至少要分出两个分支。

随着函数调用深度的增加，分支数呈指数增长，何不选个增长最缓慢的模式呢？而且，采用减枝的方式，将失败分支作为异常回滚处理，可以有效降低复杂度，提高系统健壮性和生存能力。

## 2.8 唯一编号

这个话题太大，不打算展开。在一个系统中，给对象唯一编号，可以方便对象的索引。在分布式系统中，唯一编号必不可少，内存指针局部性导致其不可向外传递，而唯一编号可以。

在分布式系统中，给对象唯一编号并不容易，无中心的系统可以采用一定的规则，用随机数编号；也可以建立多层级的、立体式的编号，比如分布式系统中每个节点唯一编号、每个节点中的进程唯一编号、每个进程中的对象按规则唯一编号、对象的每个操作唯一编号等。

## 2.9 分布式模块

前面介绍了释放this指针的方式，来表达面向对象的手法。推广一下，将this指针替换成对象的唯一编号，即可在分布式环境中使用，成为分布式模块。

分布式模块之间的通讯无非是为了回答一个哲学问题：我是谁？我要到哪里去？我要干什么？

第一个问题由本端对象的唯一编号解决；第二个问题由对端对象的唯一编号解决；第三个问题由对端对象接口的唯一编号解决。其余的都是需要传递的参数数据。

# 3 基础库

个人以为，限制使用者想像力、阻碍C成为面向对象编程语言的罪魁祸首，恐怕就是GLIBC了，看起来像初中生、高中生的水准。似乎也没人有兴趣重写一套GLIBC，只能DIY一些基本的面向对象的算法库，比如双向链表、队列、堆栈、数组、向量、红黑树、位图、字符串处理、字节处理、编解码器、内存管理器、日志组件、通信组件、信号处理、定时器处理等等。基础库提供友好接口，为上层提供可靠保障。上层实现与基础库分离，基础库的变更不影响上层逻辑，双方通过约定的接口交互。

# 4 回调与触发

回调是经典用法，充分体现了C快速、简洁的特点，因为回调也是调用。

回调也并非完美无瑕，首当其冲的是代码可读性下降、复杂度上升、传参麻烦、变量生命周期管理麻烦，其次是局部特性，不能在分布式环境中直接使用。

回顾一下通信模型。通信有收有发，通常成对出现，比如给对端发送一条请求，对端回送一条响应，请求-响应模型。一次函数调用由函数接口、参数表、返回值（函数返回值以及出参）三部分构成，可谓浓缩版通信模型：函数接口+参数表视为请求，返回值视为响应。换言之，回调可以被通信模型代替。

再审视对象之间的关系。在现实世界中，继承性并非唯一，两个对象之间可以是上下继承关系、左右平行关系、互相包含关系。如何表达任意两个对象发生关系、相互作用，是个难题。

想象一下，将对象所有支持的操作视为触角，外界与对象的交互通过触角进行，外界给一个输入，对象给一个反馈，还是经典的冯洛伊曼模型。外界与对象的交互由通信模型实现。每个对象伸出触角，接受来自任意其它对象的交互请求并给出响应。脑补一下：有无数的对象伸出触角，认识的、不认识的都可以互相交互，构成一个神经网络。

这种方式，我称之为触发。
